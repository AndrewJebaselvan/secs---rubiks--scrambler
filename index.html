<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SECS++ | Rubik's Cube Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #0d0d0d;
            color: #00ff00;
        }

        .cyber-panel {
            background-color: rgba(0, 255, 0, 0.05);
            border: 1px solid rgba(0, 255, 0, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
        }

        .cyber-button {
            border: 1px solid #00ff00;
            color: #00ff00;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px #00ff00;
        }

        .cyber-button:hover, .cyber-button.active {
            background-color: #00ff00;
            color: #0d0d0d;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .cyber-button-orange { border-color: #ff9900; color: #ff9900; text-shadow: 0 0 5px #ff9900; }
        .cyber-button-orange:hover { background-color: #ff9900; color: #0d0d0d; box-shadow: 0 0 15px #ff9900; }
        
        .cyber-button-blue { border-color: #00ffff; color: #00ffff; text-shadow: 0 0 5px #00ffff; }
        .cyber-button-blue:hover { background-color: #00ffff; color: #0d0d0d; box-shadow: 0 0 15px #00ffff; }
        
        #solutionDisplay {
            min-height: 80px;
            border: 1px solid rgba(0, 255, 0, 0.2);
            background: rgba(0,0,0,0.2);
            padding: 1rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Custom scrollbar for a cyberpunk feel */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0d0d0d; }
        ::-webkit-scrollbar-thumb { background: #00ff00; }
        ::-webkit-scrollbar-thumb:hover { background: #00cc00; }

    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8">

        <!-- Left Column: 3D Cube -->
        <div class="lg:col-span-1 flex flex-col items-center justify-center">
            <!-- Responsive cube container -->
            <div id="cube-container" class="w-full max-w-xs sm:max-w-sm md:max-w-md mx-auto aspect-square cursor-grab active:cursor-grabbing"></div>
             <p class="text-xs text-center mt-4 text-gray-400">Click and drag to rotate the cube</p>
        </div>

        <!-- Right Column: Controls -->
        <div class="lg:col-span-2 flex flex-col space-y-6">
            <header class="text-center">
                <!-- Responsive text size -->
                <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-white tracking-widest">Rubik's Cube Solver</h1>
                <p class="mt-2 text-md sm:text-lg text-green-400">Interactive 3D cube with SECS++ algorithm based solver</p>
            </header>

            <!-- Main Controls -->
            <div class="cyber-panel p-4 sm:p-6 rounded-lg">
                <h2 class="text-xl sm:text-2xl font-bold mb-4 text-white">Controls</h2>
                <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                    <input id="scrambleInput" type="text" placeholder="Optional: Enter scramble" class="flex-grow bg-transparent border border-green-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-green-300">
                    <button id="scrambleBtn" class="cyber-button-orange font-bold py-2 px-6 rounded-md">Scramble</button>
                    <button id="solveBtn" class="cyber-button font-bold py-2 px-6 rounded-md">Solve</button>
                    <button id="resetBtn" class="cyber-button-blue font-bold py-2 px-6 rounded-md">Reset</button>
                </div>
            </div>

            <!-- Manual Moves -->
            <div class="cyber-panel p-4 sm:p-6 rounded-lg">
                <h2 class="text-xl sm:text-2xl font-bold mb-4 text-white">Manual Moves</h2>
                <div class="grid grid-cols-3 sm:grid-cols-6 gap-3">
                    <!-- Programmatically generated buttons will be inserted here -->
                </div>
                 <p class="text-xs text-center mt-4 text-gray-400">Click any move to manually manipulate the cube</p>
            </div>

            <!-- Status & Solution -->
            <div class="cyber-panel p-4 sm:p-6 rounded-lg">
                <h2 class="text-xl sm:text-2xl font-bold mb-4 text-white">Status</h2>
                 <p id="statusDisplay" class="text-lg mb-4">▶ Ready</p>
                <h2 class="text-xl sm:text-2xl font-bold mb-2 text-white">Solution</h2>
                <div id="solutionDisplay" class="rounded-md font-mono text-sm"></div>
            </div>
        </div>
    </div>

    <script>
        // --- 3D CUBE SETUP (Three.js) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        const container = document.getElementById('cube-container');
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        const CUBE_SIZE = 3;
        const PIECE_SIZE = 1;
        const GAP = 0.1;

        const colors = {
            'U': 0xffffff, 'D': 0xffff00, 'F': 0x00ff00, 'B': 0x0000ff, 'L': 0xffa500, 'R': 0xff0000, 'internal': 0x1a1a1a
        };

        const pieces = [];
        const initialPiecesState = [];
        const cubeGroup = new THREE.Group();

        for (let x = 0; x < CUBE_SIZE; x++) {
            for (let y = 0; y < CUBE_SIZE; y++) {
                for (let z = 0; z < CUBE_SIZE; z++) {
                    if (x > 0 && x < CUBE_SIZE - 1 && y > 0 && y < CUBE_SIZE - 1 && z > 0 && z < CUBE_SIZE - 1) continue;

                    const pieceGeometry = new THREE.BoxGeometry(PIECE_SIZE, PIECE_SIZE, PIECE_SIZE);
                    // Correct Material Order: +X, -X, +Y, -Y, +Z, -Z
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: (x === CUBE_SIZE - 1) ? colors.R : colors.internal }), // right
                        new THREE.MeshStandardMaterial({ color: (x === 0) ? colors.L : colors.internal }), // left
                        new THREE.MeshStandardMaterial({ color: (y === CUBE_SIZE - 1) ? colors.U : colors.internal }), // up
                        new THREE.MeshStandardMaterial({ color: (y === 0) ? colors.D : colors.internal }), // down
                        new THREE.MeshStandardMaterial({ color: (z === CUBE_SIZE - 1) ? colors.F : colors.internal }), // front
                        new THREE.MeshStandardMaterial({ color: (z === 0) ? colors.B : colors.internal }), // back
                    ];

                    const piece = new THREE.Mesh(pieceGeometry, materials);
                    const position = new THREE.Vector3(
                        (x - (CUBE_SIZE - 1) / 2) * (PIECE_SIZE + GAP),
                        (y - (CUBE_SIZE - 1) / 2) * (PIECE_SIZE + GAP),
                        (z - (CUBE_SIZE - 1) / 2) * (PIECE_SIZE + GAP)
                    );
                    piece.position.copy(position);
                    
                    const quaternion = new THREE.Quaternion();
                    piece.quaternion.copy(quaternion);

                    initialPiecesState.push({ position: position.clone(), quaternion: quaternion.clone() });
                    pieces.push(piece);
                    cubeGroup.add(piece);
                }
            }
        }
        scene.add(cubeGroup);

        camera.position.set(0, 5, 7);
        camera.lookAt(0, 0, 0);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        function renderLoop() {
            requestAnimationFrame(renderLoop);
            renderer.render(scene, camera);
        }
        renderLoop();

        // --- MOUSE/TOUCH CONTROLS for cube rotation ---
        let isDragging = false;
        let previousPointerPosition = { x: 0, y: 0 };

        function onPointerDown(event) {
            isDragging = true;
            previousPointerPosition = { x: event.clientX || event.touches[0].clientX, y: event.clientY || event.touches[0].clientY };
        }

        function onPointerUp() {
            isDragging = false;
        }

        function onPointerMove(event) {
            if (!isDragging) return;
            const currentPointerPosition = { x: event.clientX || event.touches[0].clientX, y: event.clientY || event.touches[0].clientY };
            const deltaMove = {
                x: currentPointerPosition.x - previousPointerPosition.x,
                y: currentPointerPosition.y - previousPointerPosition.y
            };
            
            const rotateQuaternionY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaMove.x * 0.01);
            const rotateQuaternionX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaMove.y * 0.01);
            
            cubeGroup.quaternion.multiplyQuaternions(rotateQuaternionY, cubeGroup.quaternion);
            cubeGroup.quaternion.multiplyQuaternions(rotateQuaternionX, cubeGroup.quaternion);

            previousPointerPosition = currentPointerPosition;
        }

        container.addEventListener('mousedown', onPointerDown);
        container.addEventListener('mouseup', onPointerUp);
        container.addEventListener('mouseleave', onPointerUp);
        container.addEventListener('mousemove', onPointerMove);
        container.addEventListener('touchstart', onPointerDown, { passive: true });
        container.addEventListener('touchend', onPointerUp);
        container.addEventListener('touchmove', onPointerMove, { passive: true });
        
        // --- UI & SOLVER LOGIC ---
        const API_URL = 'http://127.0.0.1:5000/solve';
        
        const scrambleInput = document.getElementById('scrambleInput');
        const scrambleBtn = document.getElementById('scrambleBtn');
        const solveBtn = document.getElementById('solveBtn');
        const resetBtn = document.getElementById('resetBtn');
        const manualMovesContainer = document.querySelector('.grid-cols-3.sm\\:grid-cols-6');
        const statusDisplay = document.getElementById('statusDisplay');
        const solutionDisplay = document.getElementById('solutionDisplay');
        
        let isAnimating = false;

        const allMoves = ["U", "U'", "U2", "D", "D'", "D2", "F", "F'", "F2", "B", "B'", "B2", "L", "L'", "L2", "R", "R'", "R2"];
        allMoves.forEach(move => {
            const btn = document.createElement('button');
            btn.textContent = move;
            btn.className = 'cyber-button py-2 rounded-md text-sm sm:text-base';
            btn.onclick = () => {
                if(isAnimating) return;
                animateSolution([move]);
            };
            manualMovesContainer.appendChild(btn);
        });

        function setStatus(text, busy = false) {
            statusDisplay.textContent = `▶ ${text}`;
            isAnimating = busy;
            [scrambleBtn, solveBtn, resetBtn, ...document.querySelectorAll('.grid-cols-3 button')].forEach(btn => {
                btn.disabled = busy;
                btn.style.opacity = busy ? 0.5 : 1;
            });
        }

        resetBtn.addEventListener('click', () => {
             if(isAnimating) return;
             setStatus('Resetting cube...');
             solutionDisplay.innerHTML = "";
             scrambleInput.value = "";
             cubeGroup.quaternion.set(0,0,0,1);
             
             pieces.forEach((piece, index) => {
                 piece.position.copy(initialPiecesState[index].position);
                 piece.quaternion.copy(initialPiecesState[index].quaternion);
             });

             setStatus('Ready');
        });
        
        scrambleBtn.addEventListener('click', async () => {
            if (isAnimating) return;
            let scramble = scrambleInput.value.trim();
            if (!scramble) {
                const moves = ["U", "D", "F", "B", "L", "R"];
                const mods = ["", "'", "2"];
                scramble = Array(20).fill().map(() => moves[Math.floor(Math.random() * moves.length)] + mods[Math.floor(Math.random() * mods.length)]).join(' ');
                scrambleInput.value = scramble;
            }
            
            setStatus('Scrambling...', true);
            await animateSolution(scramble.split(' '));
            setStatus('Ready');
        });

        solveBtn.addEventListener('click', async () => {
            if (isAnimating) return;
            const scramble = scrambleInput.value.trim();
            if (!scramble) {
                solutionDisplay.innerHTML = `<span class="text-red-500">Error: No scramble provided. Please scramble the cube first.</span>`;
                return;
            }

            setStatus('Solving with SECS++...', true);
            solutionDisplay.innerHTML = "Contacting Python backend, please wait...";

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ scramble: scramble })
                });

                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }

                const data = await response.json();
                
                let solutionHTML = `
                    <p>Solver: <span class="text-white">${data.solver_type}</span></p>
                    <p>Moves: <span class="text-white">${data.move_count}</span></p>
                    <p class="mt-2 text-white">${data.solution_moves.join(' ')}</p>
                `;
                solutionDisplay.innerHTML = solutionHTML;

                setStatus('Animating solution...', true);
                await animateSolution(data.solution_moves);
                setStatus('Solved!');

            } catch (error) {
                console.error("Error solving cube:", error);
                solutionDisplay.innerHTML = `<span class="text-red-500">Error: Could not connect to solver. Is the api.py server running?</span>`;
                setStatus('Error', false);
            }
        });
        
        async function animateSolution(moves) {
            for (const move of moves) {
                await performMoveAnimation(move);
            }
        }

        function getPiecesForMove(face) {
            const axisMap = { 'U': 'y', 'D': 'y', 'F': 'z', 'B': 'z', 'L': 'x', 'R': 'x' };
            const sliceMap = { 'U': 1, 'D': -1, 'F': 1, 'B': -1, 'L': -1, 'R': 1 };
            const axis = axisMap[face];
            const slice = sliceMap[face];
            
            const group = [];
            for (let i = 0; i < pieces.length; i++) {
                // Use the piece's local position for stable selection
                if (Math.round(pieces[i].position[axis] / (PIECE_SIZE + GAP)) === slice) {
                    group.push(pieces[i]);
                }
            }
            return group;
        }

        async function performMoveAnimation(move) {
            const duration = 200; // ms
            const face = move[0];
            const direction = move.includes("'") ? 1 : -1;
            const times = move.includes("2") ? 2 : 1;
            const angle = (Math.PI / 2) * direction * times;
            
            const axisMap = { 
                'U': new THREE.Vector3(0, 1, 0), 'D': new THREE.Vector3(0, -1, 0), 
                'F': new THREE.Vector3(0, 0, 1), 'B': new THREE.Vector3(0, 0, -1), 
                'L': new THREE.Vector3(-1, 0, 0), 'R': new THREE.Vector3(1, 0, 0) 
            };
            const axis = axisMap[face];
            
            const movingPieces = getPiecesForMove(face);
            
            const pivot = new THREE.Group();
            scene.add(pivot);
            
            movingPieces.forEach(p => {
                cubeGroup.attach(p);
                pivot.attach(p);
            });
            
            return new Promise(resolve => {
                let start = null;
                const startQuaternion = pivot.quaternion.clone();
                const endQuaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle).multiply(startQuaternion);

                function step(timestamp) {
                    if (!start) start = timestamp;
                    const progress = Math.min((timestamp - start) / duration, 1);
                    
                    THREE.Quaternion.slerp(startQuaternion, endQuaternion, pivot.quaternion, progress);

                    if (progress >= 1) {
                        movingPieces.forEach(p => {
                            cubeGroup.attach(p);
                        });
                        scene.remove(pivot);
                        resolve();
                        return;
                    }
                    requestAnimationFrame(step);
                }
                requestAnimationFrame(step);
            });
        }
        
        function handleResize() {
            const width = container.clientWidth;
            const height = container.clientHeight;
            if(width === 0 || height === 0) return;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        window.addEventListener('resize', handleResize);
        // Initial call to set size correctly
        setTimeout(handleResize, 100);

    </script>
</body>
</html>

